import requests
import os
import webbrowser
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from xml.dom import minidom
from math import *
from scipy import stats

def toGPX(pathX, pathY):
	GPXFile = open("optimalRouteGPX.gpx", "w")
	GPXFile.write('<?xml version="1.0" encoding="UTF-8"?>\n')
	GPXFile.write('<gpx xmlns="https://github.com/fsun71/pocketSherpa" version="0.3b" creator="Franklin Sun" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n')
	GPXFile.write('<rte>\n')
	GPXFile.write('<name>Optimal path generated by pocketSherpa</name>\n')

	for coord in range(len(pathX)):
		GPXFile.write('<rtept lon="' + str(pathX[coord]) + '" lat="' + str(pathY[coord]) + '">\n')
		GPXFile.write('<ele>0</ele>\n')
		GPXFile.write('</rtept>\n')

	GPXFile.write('</rte>\n')
	GPXFile.write('</gpx>')

def GPXRead(gpxFileName):
	GPXFile = minidom.parse(gpxFileName)

	latlongData = GPXFile.getElementsByTagName('rtept')
	elevationData = GPXFile.getElementsByTagName('ele')

	XYList = []
	elevList = []

	for xyCoord in latlongData:
		tempXYContainer = []
		tempXYContainer.append(float(xyCoord.attributes['lon'].value))
		tempXYContainer.append(float(xyCoord.attributes['lat'].value))
		XYList.append(tempXYContainer)

	for elevation in elevationData:
		elevList.append(float(elevation.firstChild.data))

	delXY = []
	delElev = []
	pointGradients = []
	routeProgress = []

	for value in range(len(XYList) - 1):
		pointDelXY = greatCircleDist(XYList[value], XYList[value + 1])
		pointDelElev = elevList[value + 1] - elevList[value]

		delXY.append(pointDelXY)
		delElev.append(pointDelElev)
		pointGradients.append(pointDelElev/pointDelXY)

		routeProgress.append(value / (len(XYList) - 1))

	return delXY, delElev, pointGradients, routeProgress

def greatCircleDist(coordPair1, coordPair2):
	lon1 = toRadian(coordPair1[0])
	lat1 = toRadian(coordPair1[1])
	lon2 = toRadian(coordPair2[0])
	lat2 = toRadian(coordPair2[1])

	earthRadiusMeter = 6378.1 * 1000
	delSigma = np.arccos(sin(lat1)*sin(lat2)+cos(lat1)*cos(lat2)*cos(abs(lon2-lon1)))
	gcDist = earthRadiusMeter * delSigma
	return gcDist

def toRadian(degVal):
	return degVal * (np.pi/180)

def coordVisual():
	fig = plt.figure()
	ax = plt.axes()

	routeAnalysisDF = pd.read_csv('trailDataTraining.csv')
	x = routeAnalysisDF['Route Progress']
	y = routeAnalysisDF['Incidental Gradient']

	plt.scatter(x, y)
	plt.xlabel('Point along path')
	plt.ylabel('Point elevation change')
	plt.show()

def scrapeGPX():
	peakGeoData = pd.read_csv('data/peakGPS.csv')
	mountainNames = list(peakGeoData['Mountain'])
	
	mountainAbbrev = []

	for mountain in mountainNames:
		abbrev = mountain.lstrip('Mt. ').rstrip('Peak').rstrip('mountain').lower()
		mountainAbbrev.append(abbrev[:4])

	for abbrev in mountainAbbrev:
		try:
			webbrowser.open('https://www.14ers.com/php14ers/download.php?file=' + abbrev + '1_route.gpx&type=routegpx')
		except:
			print('Download failure at ' + abbrev)

def cleanGPXData():
	i = 1
	for filename in os.listdir('data/gpxData'):
		oldName = 'data/gpxData/' + filename
		newName = 'data/gpxData/trainingRoute' + str(i) + '.gpx'
		os.rename(oldName, newName)
		i += 1

def compileTrainingData():
	routeProgressTraining = []
	pointGradientsTraining = []
	delXYTraining = []
	delElevTraining = []

	for i in range(1, 58):
		dataFileName = 'data/gpxData/trainingRoute' + str(i) + '.gpx'
		try:
			delXY, delElev, pointGradients, routeProgress = GPXRead(dataFileName)
		except IndexError:
			print('Index error in training file ' + str(i))
		print(i)

		for item in range(len(delXY)):
			routeProgressTraining.append(routeProgress[item])
			pointGradientsTraining.append(pointGradients[item])
			delXYTraining.append(delXY[item])
			delElevTraining.append(delElev[item])

	trailDataArray = np.array([routeProgressTraining, pointGradientsTraining, delXYTraining, delElevTraining])
	trailDF = pd.DataFrame(trailDataArray.transpose(), columns = ['Route Progress', 'Incidental Gradient', 'GRD', 'Delta Elevation'])
	trailDF = trailDF.replace(0, np.nan)
	trailDF = trailDF.dropna()
	trailDF.sort_values(by = ['Route Progress'])
	trailDF = trailDF[(np.abs(stats.zscore(trailDF)) < 2).all(axis=1)]
	export_csv = trailDF.to_csv("trailDataTraining.csv", index = None, header = True)

#compileTrainingData()
#coordVisual()
